/********************************************************************************************************************************
 * KM_8600_v330.c
 *
 * Created: 11.07.2015 15:42:51
 *  Author: Ed
 * version: 3.30
 *
 * Программа для KM01-8600.M0
 * Программа никакой полезной функциональности не несет и сделана как шаблон для дальнейшего наполнения полезной функциональности
 * Смотреть описание карты регистров!
 ********************************************************************************************************************************/ 
/* Используемые выводы контроллера ATMEGA324PA
* PA0 - input IN1
* PA1 - input IN2
* PA2 - input IN3
* PA3 - input IN4
* PA4 - input IN5
* PA5 - input IN6
* PA6 - input IN7
* PA7 - input IN8
*
* PB0 - input UIN (Контроль напряжения питания цифровых входов)
* PB1 - NC
* PB2 - NC
* PB3 - output LD (выход управления зеленым светодиодом ПИТАНИЕ на панели индикации)
* PB4 - output SS(SPI) (выход управления выводом информации загруженой в регистры сдвига на панели индикации)
* PB5 - output MOSI(SPI) (выход последовательной загрузки данных в сдвиговые регистры панели индикации)
* PB6 - input MOSO(SPI) (вход для программирования контроллера по интерфейсу SPI)
* PB7 - output SCK(SPI) (выход синхронизации для обмена по SPI)
*
* PC0 - output DO6 (ОК)
* PC1 - output DO5 (ОК)
* PC2 - output DO4 (реле)
* PC3 - output DO3 (реле)
* PC4 - output DO2 (реле)
* PC5 - output DO1 (реле)
* PC6 - NC
* PC7 - NC
*
* PD0 - input RX(UART) (вход RX для работы по UART (подтянут к +))
* PD1 - output TX(UART) (выход TX для работы по UART)
* PD2 - output TXE(RS485) (выход для управления направления обмена по RS485)
* PD3 - NC
* PD4 - NC
* PD5 - NC
* PD6 - NC
* PD7 - input JP (вход подтянут к +, используется для активизации bootloader)
***********************************************************************************************************************************
* Внесенные изменения: 16.03.2014
* исправил регистры счетных входов, увеличил кол-во регистров Input и Hold для резерва. теперь можно считывать до 124 регистров.
* исправил индикацию флагов в регистре состояния выходов. 
* Новые не задействованные регистры Input и Hold можно использовать в программе пользователя!!!
* Внесенные изменения: 11.07.2015 Переделан принцип работы, убран файл task, задачи выполняются непосредственно по таймеру1
* Ответы на запросы модбас отсылаются из основной программы. 13.07.2015 (проверено).
**********************************************************************************************************************************/
// --- Основные объявления ---
// размер буфера макс = 255!!!
#define F_CPU 14745600UL 			
#define COM_RX_BUFFER_SIZE 255		
#define COM_TX_BUFFER_SIZE 255		

// --- Включаемые стандартные библиотеки ---
#include <avr/io.h>
#include <avr/eeprom.h>
#include <avr/pgmspace.h>

// --- Включаемые sem библиотеки ---
#include "km_8600.h"
#include "net.h"
#include "ioport.h"
#include "mem.h"

void user_main(void);		// объявление пользовательской функции
void work_sys(void);		// объявление для использования в любом месте программы

//------------------- Сообщение компилятора (для информации) -----------------------
#ifdef	_KM8600_
#warning "MESSAGE - Select type device - KM01-8600.M ver.0330"
#endif
//================== Работа с собачьм таймером ======================================
/* На будущее
void InitWdt(void)
{
	MCUSR &= ~(1<<WDRF); 			// д.б. сброшен (если = 1, то и WDE = 1 !!!)
	asm("wdr");						// сброс счетчика WDT
	WDTCSR |= (1<<WDE)|(1<<WDCE);	// для сброса WDE - надо делать так!
	WDTCSR = 0x0F;					// 2 сек и разрешен сброс по тайм ауту
}
*/
// ============ takt_timer выполняется по прерыванию каждые 10 мсек =================
void takt_timer(void)
{  unsigned char n;
	n = TimerTakt;
	if (n) TimerTakt = --n;		// Время выполнения основного цикла
	n = TimerLed;
	if (n) TimerLed = --n;		// Уменьшить счетчик
}
// ============ Обработка прерывания таймера 1 (каждые 10 мсек) =====================
ISR(TIMER1_OVF_vect)
{
	TCNT1H = 0xFF;
	TCNT1L = 255 - 144;
	takt_timer();
}
//=========================== Функция инициализации ядра ============================
void Init(void)
{
unsigned char i;

	_delay_ms(500);		// Задержка при старте
	InitLine();			// Настраиваю порты контроллера
//	InitWdt();			// Настройка сторожевого таймера (пока в резерве
	LD_on;				// Включить зеленый светодиод
	WDR();				// Сброс собачьего таймера
	_delay_ms(500);		// Задержка при старте
	for(i=0; i<maxAddrRegINP;i++) { MB_Ireg[i] = 0; }	// Очистить INPUT регистры
	for(i=0; i<maxAddrRegHOLD; i++) { MB_Hreg[i] = 0; }	// Очистить HOLD регистры
	_delay_ms(100);		// Задержка
	WDR();				// Сброс собачьего таймера
	if((PIND & 0x80) == 0) 
		{ 
			set_default(); 
			for(i=0; i<5; i++) // Моргнуть 5 раз!
			{
			LD_off; 
			_delay_ms(100); 
			LD_on; 
			_delay_ms(100); 
			}
		}
	WDR();						// Сброс собачьего таймера
	InitMem();					// Заполняю регистры Модбас данными из памяти
	CNT_clear();				// Очистить счетные регистры
	WDR();						// Сброс собачьего таймера
	InitDev();					// Инициализация внутренних систем контроллера
	LD_off;						// Выключить зеленый светодиод
	MB_Ireg[27] = 0x0000;		// выкл все
	LED_Update();				// Обновить
	WDR();						// Сброс собачьего таймера
	_delay_ms(1000);			// Тест светодиодов (проверка работоспособности)
	MB_Ireg[27] = 0xFF00;		// вкл входы
	LED_Update();				// Обновить
	WDR();						// Сброс собачьего таймера
	_delay_ms(500);				// Тест светодиодов (проверка работоспособности)
	MB_Ireg[27] = 0x003F;		// Вкл выходы
	LED_Update();				// Обновить
	WDR();						// Сброс собачьего таймера
	_delay_ms(500);				// Тест светодиодов (проверка работоспособности)
	MB_Ireg[27] = 0x0040;		// Включить красный
	LED_Update();				// Обновить
	WDR();						// Сброс собачьего таймера
	_delay_ms(500);				// Тест светодиодов (проверка работоспособности)
	MB_Ireg[27] = 0x0000;		// выкл все
	LED_Update();				// Обновить
	LD_on;						// Включить зеленый светодиод
	WDR();						// Сброс собачьего таймера
	_delay_ms(500);				// Тест светодиодов (проверка работоспособности)
	WDR();						// Сброс собачьего таймера
	INP_Read();					// Считываю текущие состояния входов
	COM_Init((char) MB_Hreg[62],(char) (MB_Hreg[62] >> 8)); // Настраиваю UART0 для работы RS-485
	Address_device = (char) MB_Hreg[61];					// Переписываю адрес контроллера в сети ModBus
	// ----- Настраиваю работу таймера №1 ----
	TCCR1B = (1 << CS12)|(1<< CS10);	// Timer1 / 1024 - делим тактовую на 1024
	TCNT1H = 0xFF;
	TCNT1L = 255 - (F_CPU / 1024 / 100);	// Прерывания каждые 10мсек!
	TIMSK1 |= (1<<TOIE1);					// Включить прерывания Timer 1 при переполнении
}

// =========================== Команда перезагрузки контроллера ====================================================
void command_reboot(void)
{
//if((MB_Hreg[63] &0x01) != 0) {cli(); while(1);} // Перезагрузка по сбросу собачьего таймера (пока в резерве)
if((MB_Hreg[63] &0x01) != 0) {_delay_ms(20); asm("rjmp restart;");} // Если есть 1 то перейти на метку перезагрузки
}
//============================ Работа ядра системы =================================================================
int main(void)
{
	// --- Инициализация ---
	cli();
	_delay_ms(500);	// Задержка при старте
asm("restart:");	// Метка для перехода по команде перезагрузки
	Init();			// Инициализация системы...
	sei();			// Разрешить глобальные прерывания	
	TimerTakt = 10; // Задачу выполнять каждые 100мсек
	TimerLed = 0;	// Светодиод включен!
	while(1)
	{
		WDR(); // Сброс собачьего таймера
		if(Read_Modbus() == 1)	{TimerLed = 10; MODBUS_RTU();}	// Если пакет принят, обработать принятый пакет ModBus
		if(TimerLed) LD_off; else LD_on; // выключить светодиод на 100мсек - принят пакет с адресом модуля
		if(TimerTakt == 0)
		{
			TimerTakt = 10; // Перезагрузка таймера - следующее выполнение программы через 10*10=100мсек
			// --- Состояния входов в рег Input меняются по прерываниям ---
			OUT_Read();			// Чтение состояния выходов
			IND_Update();		// Обновить состояние индикации
			//******************Здесь м.б. программа пользователя***********************************
			
			//**************************************************************************************
			OUT_Update();		// Обновить состояние дискретных выходов
			rd_cnt();			// Обновить показания счетчиков
			command_reboot();	// Проверить команду - не пора ли перезагрузиться???
			// === Формирую слово жизни контроллера ===
			if(MB_Ireg[0] <= 0xFFFA) MB_Ireg[0]++;
			else MB_Ireg[0] = 0;
		}
	}
}

//***************************************************************************** END ************************************************************************************