#ifndef _IOPORT_													//Защита от повторного включения файла
#define _IOPORT_

#include <avr/io.h>												//Стандартная библиотека ввода/вывода
#include <util/delay.h>											//Стандартная библиотека временных задержек
#include <avr/interrupt.h>										//Стандартная библиотека обработки прерываний

#include "km_8600.h"											// Загрузить заголовок

#ifndef F_CPU
#warning "F_CPU not defined. Frequency by default 14.7456MHz"
#define F_CPU 14745600UL		/*Стандартная константа задающая частоту микроконтроллера (необходима для корректной работы функций задержек)*/
#endif

// === Объявляю структуру для счетных входов
typedef struct
{
	unsigned char stat;			// Состояние памяти предыдущего цикла
	unsigned int pre_cnt1;			// Предделитель счетчика №1
	unsigned long int cnt1;			// Значение счетчика №1
	unsigned int pre_cnt2;			// Предделитель счетчика №2
	unsigned long int cnt2;			// Значение счетчика №2
	unsigned int pre_cnt3;			// Предделитель счетчика №3
	unsigned long int cnt3;			// Значение счетчика №3
	unsigned int pre_cnt4;			// Предделитель счетчика №4
	unsigned long int cnt4;			// Значение счетчика №4
	unsigned int pre_cnt5;			// Предделитель счетчика №5
	unsigned long int cnt5;			// Значение счетчика №5
	unsigned int pre_cnt6;			// Предделитель счетчика №6
	unsigned long int cnt6;			// Значение счетчика №6
	unsigned int pre_cnt7;			// Предделитель счетчика №7
	unsigned long int cnt7;			// Значение счетчика №7
	unsigned int pre_cnt8;			// Предделитель счетчика №8
	unsigned long int cnt8;			// Значение счетчика №8
} counters;

counters count;			// === Объявление рабочей структуры для счетчиков ===

//=========================== Фукция инициализации портов входа/выхода ====================
void InitLine(void)
{
	// --- настраиваю входы/выходы для контроллера КМ01-8600.М ---
	PORTA = 0x00;		// не подтягиваем к + входы DI0...DI7
	DDRA  = 0x00;		// Выводы  DI0...DI7 - входы
	PORTB = 0x10;		// на выходе SS д.б. 1
	DDRB  = 0xB8;		// Выводы MOSI,SCK,SS,LD -выходы
	PORTC = 0x00;		// на выходах - 0
	DDRC  = 0x3F;		// Выводы  DO0...DO5 -выходы
	PORTD = 0x81;		// подтягиваем к + JP1,RX
	DDRD  = 0x06;		// Выводы  JP1 - вход, TXE и TX - выходы
}

/*******************************************************************************
* Функция настройки внутренних устройств контроллера
********************************************************************************/
void InitDev(void)
{
unsigned char i;
	// --- настраиваю прерывания по изменению состояния входов ---
	PCICR |= (1<<PCIE1) | (1<<PCIE0);								// Разрешение прерывания для группы PCINT0...PCINT7 и PCINT8...PCINT15 (PORTA и PORTB)
	PCMSK0 |= (1<<PCINT7) | (1<<PCINT6) | (1<<PCINT5) | (1<<PCINT4) | (1<<PCINT3) | (1<<PCINT2) | (1<<PCINT1) | (1<<PCINT0); //Разрешить прерывания PCINT0...PCINT7 (DI1...DI8)
	PCMSK1 |= (0<<PCINT7) | (0<<PCINT6) | (0<<PCINT5) | (0<<PCINT4) | (0<<PCINT3) | (0<<PCINT2) | (0<<PCINT1) | (1<<PCINT0); // Разрешить прерывания PCINT8 (UDI)
	// --- настраиваю работу ШИМ для выходов с ОК (DO5, DO6) ---
	if((MB_Hreg[34] & 0x03) != 0)	// Если разрешена работа хотя-бы одного из выходов
		{
			TCCR2A = (1<<WGM21)|(1<<WGM20);						// тип ШИМ - FastPWM
			i = ((MB_Hreg[34] >> 8) & 0x03);					// определяю категорию частоты ШИМ
				switch (i)
					{
						case 1:  TCCR2B = (1<<WGM20)|(1<<CS22)|(1<<CS20); break;			// делитель 1:128 (ШИМ порядка 120Гц)
						case 2:  TCCR2B = (1<<WGM20)|(1<<CS22)|(0<<CS21); break;			// делитель 1:64  (ШИМ порядка 240Гц)
						case 3:  TCCR2B = (1<<WGM20)|(1<<CS21)|(1<<CS20); break;			// делитель 1:32  (ШИМ порядка 480Гц)
						default: TCCR2B = (1<<WGM20)|(1<<CS22)|(1<<CS21); break;			// делитель 1:256 (ШИМ порядка 60Гц)
					}
			TIMSK2 = (1<<OCIE2B) | (1<<OCIE2A) | (1<<TOIE2);	// Разрешаю прерывания по совпадению А,В и переполнению таймера 2
		OCR2A = 0x00;	// Изначально пусть будет 0
		OCR2B = 0x00;	// Изначально пусть будет 0
		}
	// --- настраиваю работу SPI для индикации ---
	SPCR0 = ( 1 << SPE0 ) | ( 1 << MSTR0 ); // разрешаем SPI, Master, режим 0, частота 1/4 от F_CPU, LSB first
	SPSR0 = ( 1 << SPI2X0 ); //удвоение частоты SPI
}
//============================================ РАБОТА С ПАНЕЛЬЮ ИНДИКАЦИИ ==========================================================
//==================================================================================================================================
 /******************************************************************************
 Передача данных на SPI для индикации - обновление индикации
 ******************************************************************************/
 void LED_Update(void)
 {
 char b; // Рабочая переменная
 PORTB &= (~(0x01 << 0x04));	// Начинаем загрузку (вывод SS установить в 0)
 b = (char)(MB_Ireg[27] >> 8);
 SPDR0 = b;
 while(!(SPSR0&(1<<SPIF0)));	// Ждем пока завершиться передача
 b = (char)(MB_Ireg[27]);
 SPDR0 = b;
 while(!(SPSR0&(1<<SPIF0)));	// Ждем пока завершиться передача
 PORTB |= (0x01 << 0x04);		// Выводим данные (вывод SS установить в 1)
 }
 /*****************************************************************************
 *	Обновление состояния регистра индикации
 ******************************************************************************/
 void IND_Update(void)
{
char i;
 for(i=0; i<8; i++) // Записываю состояния входов в рег. индикации
 {
	 if((PINA & (1<<i)) == 0) MB_Ireg[27] &= ~(1<<(15-i));	// установить бит в 0
	 else MB_Ireg[27] |= (1<<(15-i));						// установить бит в 1
 }
 if ((PINB & 0x01) == 0) MB_Ireg[27] |= (0x40);				// установить в 1, Состояние питания входов (инверсно)
 else MB_Ireg[27] &= ~(0x40);								// Установить в 0
 for(i=0; i<4; i++)											// Записываю состояния выходов в рег. индикации
   {														// для релейных выходов DO1,DO2,DO3,DO4
	if((PINC & (1<<(2+i))) == 0) MB_Ireg[27] &= ~(1<<(2+i));	// установить бит в 0
	else MB_Ireg[27] |= (1<<(2+i));								// установить бит в 1
   }
  // ========= для выходов индикации работающих по ШИМ ===========
  i = MB_Hreg[34] & 0x03; // Получаю состояние работы ШИМ выводов
  switch (i)
  {
	  case 1:		// DO5 - в режиме ШИМ
			if(MB_Hreg[8] > 0) MB_Ireg[27] |= 0x02;			// установить бит в 1 для DO5
			else MB_Ireg[27] &= ~(0x02);					// установить бит в 0 для DO5
			if((PINC & 0x01) == 0) MB_Ireg[27] &= ~(0x01);	// установить бит в 0 для DO6
			else MB_Ireg[27] |= (0x01);						// установить бит в 1 для DO6
	  break;
	  case 2:		// DO6 - в режиме ШИМ
			if(MB_Hreg[9] > 0) MB_Ireg[27] |= 0x01;			// установить бит в 1 для DO6
			else MB_Ireg[27] &= ~(0x01);					// установить бит в 0 для DO6
			if((PINC & 0x02) == 0) MB_Ireg[27] &= ~(0x02);	// установить бит в 0 для DO5
			else MB_Ireg[27] |= (0x02);						// установить бит в 1 для DO5
	  break;
	  case 3:		// DO5 и DO6 - в режиме ШИМ
			if(MB_Hreg[8] > 0) MB_Ireg[27] |= 0x02;			// установить бит в 1 для DO5
			else MB_Ireg[27] &= ~(0x02);					// установить бит в 0 для DO5
			if(MB_Hreg[9] > 0) MB_Ireg[27] |= 0x01;			// установить бит в 1 для DO6
			else MB_Ireg[27] &= ~(0x01);					// установить бит в 0 для DO6
	  break;
	  default:		// нет режима ШИМ
			if((PINC & 0x02) == 0) MB_Ireg[27] &= ~(0x02);	// установить бит в 0 для DO5
			else MB_Ireg[27] |= (0x02);						// установить бит в 1 для DO5
			if((PINC & 0x01) == 0) MB_Ireg[27] &= ~(0x01);	// установить бит в 0 для DO6
			else MB_Ireg[27] |= (0x01);						// установить бит в 1 для DO6
	  break;
  } 
 LED_Update(); // Обновляем индикацию
 }

//=============================================== РАБОТА С ЛИНИЯМИ ВВОДА/ВЫВОДА ===================================================
//=================================================================================================================================
//=========================== Функция чтения состояния входов =====================================================================
//Функция принимает в качестве параметров: port_line - Линия ввода/вывода (от 0 до maxAddr_DI)
//Функция возвращает: Состояние линии (0x01-высокий уровень/0x00-низкий уровень/0xFF-не верный номер линии)
// считывает состояние только одной линии входа
//=================================================================================================================================
char InState(unsigned char port_line)
{
//------------------------ Для контроллера КМ8600 ---------------------------------
	if(port_line < maxAddr_DI) {return ((MB_Ireg[1] >> port_line) & 0x01);}	// Чтение состояния входов и возврат с полученным значением
	else return 0xFF;															// вернуться с ошибкой
}

//=========================== Функция чтения состояния выходов =============================
//Функция принимает в качестве параметров: port_line - Линия вывода (от 0 до maxAddr_DO)
//Функция возвращает: Состояние линии (0x01-высокий уровень/0x00-низкий уровень/0xFF-не верный номер линии)
// считывает состояние только одной линии входа
//=========================================================================================
char OutState(unsigned char port_line)
{
//------------------------ Для контроллера КМ8600 ---------------------------------
	if(port_line < maxAddr_DO) {return ((MB_Ireg[2] >> port_line) & 0x01);}	// Чтение состояния выходов и возврат с полученным значением
	else return 0xFF;														// вернуться с ошибкой	
}

//========================== Функция установки цифровых выходов ===========================
//Функция принимает в качестве параметров:
//port_line - Линия ввода/вывода (от 0 до maxAddr_DO)
//level     - Устанавливаемый уровень (0 - низкий/1-высокий)
//Функция возвращает:
//0x00-если указан корректный номер линии, в противном случае 0xFF
//=========================================================================================

char OutControl(char port_line, char level)
{
//------------------- Для контроллера КМ8600 --------------------
	if ((port_line >= maxAddr_DO) || (level > 1) ) return 0xFF;	//Если указана не существующая линия порта или не верный уровень сигнала, выход с ошибкой
	if (level!=0x00) {MB_Hreg[5] |= (0x01 << port_line);	return 0x01;} //Установка состояния линии в 1
	else { MB_Hreg[5] &= ~(0x01 << port_line);}			//Установка состояния линии в 0
	return 0;
}

//=========================================================== КОНТРОЛЬ СОСТОЯНИЯ ДИСКРЕТНЫХ ЛИНИЙ ВВОДА ==================================================
//========================================================================================================================================================
// --- Чтение состояния входов (надо при старте, т.к. дальнейшие изменения состояния работают по прерыванию) ---
void INP_Read(void)
{
	for(char i=0;i<8;i++) // считывает состояние 3 бит
	{
		if((PINA & (1<<i)) == 0) MB_Ireg[1] &= ~(1<<i);// установить бит в 0
		else MB_Ireg[1] |= (1<<i);						// установить бит в 1
	}
}
 /******************************************************************************
 * Обработка прерывания по изменению состояния входов DI1,DI2,DI3,DI4,DI5,DI6,DI7
 ******************************************************************************/
 ISR(PCINT0_vect)
{ // пишем состояние всего регистра PINA в регистр Input
char i;
	for(i=0;i<8;i++) // считывает состояние 8 бит
		{
		if((PINA & (1<<i)) == 0) MB_Ireg[1] &= ~(1<<i);// установить бит в 0
		else MB_Ireg[1] |= (1<<i);						// установить бит в 1
		}
// Проверяем работу счетных входов!
// =========== если задана работа счетного входа №1 ============================
if((MB_Hreg[35] & 0x01) != 0)
{
	if(((PINA & 0x01) != 0) & ((count.stat & 0x01) == 0)) // если на входе 1, а был 0
	{
		count.pre_cnt1++;			// увеличить предделитель на 1
		count.stat |= 0x01;		// защита от повторного входа
		if(count.pre_cnt1 >= MB_Hreg[36]) {count.pre_cnt1 = 0; count.cnt1++;} // собственно счет
	}
	if((PINA & 0x01) == 0) count.stat &= ~(0x01); // Если на входе 0 - взвести счетчик и ждать очередной 1!
}
// ================ если задана работа счетного входа №2 =============================================
if((MB_Hreg[35] & 0x02) != 0)
{
	if(((PINA & 0x02) != 0) & ((count.stat & 0x02) == 0)) // если на входе 1, а был 0
	{
		count.pre_cnt2++;			// увеличить предделитель на 1
		count.stat |= 0x02;		// защита от повторного входа
		if(count.pre_cnt2 >= MB_Hreg[39]) {count.pre_cnt2 = 0; count.cnt2++;} // собственно счет
	}
	if((PINA & 0x02) == 0) count.stat &= ~(0x02); // Если на входе 0 - взвести счетчик и ждать очередной 1!
}
// ================ если задана работа счетного входа №3 =============================================
if((MB_Hreg[35] & 0x04) != 0)
{
	if(((PINA & 0x04) != 0) & ((count.stat & 0x04) == 0)) // если на входе 1, а был 0
	{
		count.pre_cnt3++;			// увеличить предделитель на 1
		count.stat |= 0x04;		// защита от повторного входа
		if(count.pre_cnt3 >= MB_Hreg[42]) {count.pre_cnt3 = 0; count.cnt3++;} // собственно счет
	}
	if((PINA & 0x04) == 0) count.stat &= ~(0x04); // Если на входе 0 - взвести счетчик и ждать очередной 1!
}
// ================ если задана работа счетного входа №4 =============================================
if((MB_Hreg[35] & 0x08) != 0)
{
	if(((PINA & 0x08) != 0) & ((count.stat & 0x08) == 0)) // если на входе 1, а был 0
	{
		count.pre_cnt4++;			// увеличить предделитель на 1
		count.stat |= 0x08;			// защита от повторного входа
		if(count.pre_cnt4 >= MB_Hreg[45]) {count.pre_cnt4 = 0; count.cnt4++;} // собственно счет
	}
	if((PINA & 0x08) == 0) count.stat &= ~(0x08); // Если на входе 0 - взвести счетчик и ждать очередной 1!
}
// ================ если задана работа счетного входа №5 =============================================
if((MB_Hreg[35] & 0x10) != 0)
{
	if(((PINA & 0x10) != 0) & ((count.stat & 0x10) == 0)) // если на входе 1, а был 0
	{
		count.pre_cnt5++;			// увеличить предделитель на 1
		count.stat |= 0x10;			// защита от повторного входа
		if(count.pre_cnt5 >= MB_Hreg[48]) {count.pre_cnt5 = 0; count.cnt5++;} // собственно счет
	}
	if((PINA & 0x10) == 0) count.stat &= ~(0x10); // Если на входе 0 - взвести счетчик и ждать очередной 1!
}
// ================ если задана работа счетного входа №6 =============================================
if((MB_Hreg[35] & 0x20) != 0)
{
	if(((PINA & 0x20) != 0) & ((count.stat & 0x20) == 0)) // если на входе 1, а был 0
	{
		count.pre_cnt6++;			// увеличить предделитель на 1
		count.stat |= 0x20;			// защита от повторного входа
		if(count.pre_cnt6 >= MB_Hreg[51]) {count.pre_cnt6 = 0; count.cnt6++;} // собственно счет
	}
	if((PINA & 0x20) == 0) count.stat &= ~(0x20); // Если на входе 0 - взвести счетчик и ждать очередной 1!
}
// ================ если задана работа счетного входа №7 =============================================
if((MB_Hreg[35] & 0x40) != 0)
{
	if(((PINA & 0x40) != 0) & ((count.stat & 0x40) == 0)) // если на входе 1, а был 0
	{
		count.pre_cnt7++;			// увеличить предделитель на 1
		count.stat |= 0x40;			// защита от повторного входа
		if(count.pre_cnt7 >= MB_Hreg[54]) {count.pre_cnt7 = 0; count.cnt7++;} // собственно счет
	}
	if((PINA & 0x40) == 0) count.stat &= ~(0x40); // Если на входе 0 - взвести счетчик и ждать очередной 1!
}
// ================ если задана работа счетного входа №8 =============================================
if((MB_Hreg[35] & 0x80) != 0)
{
	if(((PINA & 0x80) != 0) & ((count.stat & 0x80) == 0)) // если на входе 1, а был 0
	{
		count.pre_cnt8++;			// увеличить предделитель на 1
		count.stat |= 0x80;			// защита от повторного входа
		if(count.pre_cnt8 >= MB_Hreg[57]) {count.pre_cnt8 = 0; count.cnt8++;} // собственно счет
	}
	if((PINA & 0x80) == 0) count.stat &= ~(0x80); // Если на входе 0 - взвести счетчик и ждать очередной 1!
}
} 
 /******************************************************************************
 * Обработка прерывания по изменению состояния входа UDI
 ******************************************************************************/
 ISR(PCINT1_vect)
 { // пишем состояние входа наличия напряжения на входах
	if((PINB & 0x01) == 0)	 MB_Ireg[1] |= (0x0100); // если напр нет - устанавливаем бит в 1
	else MB_Ireg[1] &= ~(0x0100);					// если напр есть - бит = 0
} 

//================================== РАБОТА С ШИМ ДЛЯ ЦИФРОВЫХ ВЫХОДОВ =================================================================
//======================================================================================================================================
/******************************************************************************
 * Обработка прерывания по совпадение А таймера/счетчика Т2
 ******************************************************************************/
ISR(TIMER2_COMPA_vect)
{	// если работа разрешена то
  if((MB_Hreg[34] & 0x01) != 0) PORTC |= 0x02;	// Если разрешена работа ШИМ -> DO5 установить выход в 1
}
  
/******************************************************************************
 * Обработка прерывания по совпадение В таймера/счетчика Т2
 ******************************************************************************/
ISR(TIMER2_COMPB_vect)
{	// если работа разрешена то
  if((MB_Hreg[34] & 0x02) != 0) PORTC |= 0x01;	// Если разрешена работа ШИМ -> DO6 установить выход в 1
}

/******************************************************************************
 * Обработка прерывания по переполнение таймера/счетчика Т2
 ******************************************************************************/
ISR(TIMER2_OVF_vect)
{	// если работа разрешена то
  if((MB_Hreg[34] & 0x01) != 0) PORTC &= ~(0x02);	// Если разрешена работа ШИМ -> DO5 установить выход в 0
  if((MB_Hreg[34] & 0x02) != 0) PORTC &= ~(0x01);	// Если разрешена работа ШИМ -> DO6 установить выход в 0
}

//======================================================== РАБОТА С ВЫХОДАМИ =============================================================
//========================================================================================================================================
/*******************************************************************************
*	Функция чтения состояния выходов
********************************************************************************/
void OUT_Read(void)
{
	char i;
	// --- Чтение состояния выходов ---
	for(i=0;i<4;i++) // только 6 выходов
	{
		if((PINC & (1<<(5-i))) == 0) MB_Ireg[2] &=~(0x01 << i);	// установить 0
		else MB_Ireg[2] |=0x01 << i;							// установить 1
	}
	if((MB_Hreg[34] & 0x01) != 0) // для выхода №5
		{
			if(MB_Hreg[8] > 0) MB_Ireg[2] |= 0x10;
			else MB_Ireg[2] &= ~(0x10);
		}
	else
		{
			if((PINC & 0x02) == 0) MB_Ireg[2] &= ~(0x10);	// установить 0
			else MB_Ireg[2] |= 0x10;
		}
	if((MB_Hreg[34] & 0x02) != 0) // Для выхода №6
	{
		if(MB_Hreg[9] > 0) MB_Ireg[2] |= 0x20;
		else MB_Ireg[2] &= ~(0x20);
	}
	else
	{
		if((PINC & 0x01) == 0) MB_Ireg[2] &= ~(0x20);	// установить 0
		else MB_Ireg[2] |= 0x20;
	}
}

/*******************************************************************************
*	Функция обновления состояния выходов (работа из основной программы)
********************************************************************************/
void OUT_Update(void)
{
char i;
	// --- Изменение состояния выходов ---
	for(i=0;i<4;i++) // первые 4 выхода (реле)
	{
		if((MB_Hreg[5] & (1<<i)) == 0) PORTC&=~(0x01 << (5-i));	// установить 0
		else PORTC|=0x01 << (5-i);								// установить 1
	}
	// --- для выходов с ОК ---
	i = MB_Hreg[34] & 0x03;
	switch (i)
	{
		case 1:							// если в качестве ШИМ работает только DO5
			OCR2A = (char) MB_Hreg[8];	// Значение в регистр управления для DO5
			OCR2B = (char) MB_Hreg[9];	// Значение в регистр управления для DO6
			if((MB_Hreg[5] & 0x20) == 0) PORTC&=~(0x01);	// установить 0 DO6
			else PORTC|=0x01;								// установить 1	DO6
		break;
		case 2:							// если в качестве ШИМ работает только DO6
			OCR2A = (char) MB_Hreg[8];	// Значение в регистр управления для DO5
			OCR2B = (char) MB_Hreg[9];	// Значение в регистр управления для DO6
			if((MB_Hreg[5] & 0x10) == 0) PORTC&=~(0x02);	// установить 0 DO5
			else PORTC|=0x02;								// установить 1	DO5
		break;
		case 3:							// если в качестве ШИМ работает DO5 и DO6
			OCR2A = (char) MB_Hreg[8];	// Значение в регистр управления для DO5
			OCR2B = (char) MB_Hreg[9];	// Значение в регистр управления для DO6
		break;
		default:						// Если выходы DO5,DO6 не в режиме ШИМ 
			if((MB_Hreg[5] & 0x10) == 0) PORTC&=~(0x02);	// установить 0
			else PORTC|=0x02;								// установить 1
			if((MB_Hreg[5] & 0x20) == 0) PORTC&=~(0x01);	// установить 0
			else PORTC|=0x01;								// установить 1
		break;
	}
	// --- Перенесу значения регистров ШИМ ---
	if((MB_Hreg[34] & 0x01) != 0) MB_Ireg[9] = MB_Hreg[8];
	else MB_Ireg[9] = 0;
	if((MB_Hreg[34] & 0x02) != 0) MB_Ireg[10] = MB_Hreg[9];
	else MB_Ireg[10] = 0;
}

//================================================ РАБОТА СЧЕТНЫХ ВХОДОВ ==================================================================
//=========================================================================================================================================
// === Очистить счетные регистры ===
void CNT_clear(void)
{
count.stat = 0;
count.pre_cnt1 = 0;
count.cnt1 = 0;
count.pre_cnt2 = 0;
count.cnt2 = 0;
count.pre_cnt3 = 0;
count.cnt3 = 0;
count.pre_cnt4 = 0;
count.cnt4 = 0;
count.pre_cnt5 = 0;
count.cnt5 = 0;
count.pre_cnt6 = 0;
count.cnt6 = 0;
count.pre_cnt7 = 0;
count.cnt7 = 0;
count.pre_cnt8 = 0;
count.cnt8 = 0;
}

// === Перенос значений счетных регистров в регистры INPUT ===
void rd_cnt(void)
{
unsigned long int c = 0;									// Рабочая переменная
  c = count.cnt1 + (((unsigned long int)MB_Hreg[44] << 16) + MB_Hreg[45]);	// коррекция значения счетчика №1
  MB_Ireg[11] = (c >> 16) & 0xFFFF;							// запись старшего числа счетчика №1
  MB_Ireg[12] = c & 0xFFFF;									// запись младшего числа счетчика №1
  c = 0;
  c = count.cnt2 + (((unsigned long int)MB_Hreg[46] << 16) + MB_Hreg[47]);	// коррекция значения счетчика №2
  MB_Ireg[13] = (c >> 16) & 0xFFFF;							// запись старшего числа счетчика №2
  MB_Ireg[14] = c & 0xFFFF;									// запись младшего числа счетчика №2
  c = 0;
  c = count.cnt3 + (((unsigned long int)MB_Hreg[48] << 16) + MB_Hreg[49]);	// коррекция значения счетчика №3
  MB_Ireg[15] = (c >> 16) & 0xFFFF;							// запись старшего числа счетчика №3
  MB_Ireg[16] = c & 0xFFFF;									// запись младшего числа счетчика №3
  c = 0;
  c = count.cnt4 + (((unsigned long int)MB_Hreg[50] << 16) + MB_Hreg[51]);	// коррекция значения счетчика №4
  MB_Ireg[17] = (c >> 16) & 0xFFFF;							// запись старшего числа счетчика №4
  MB_Ireg[18] = c & 0xFFFF;									// запись младшего числа счетчика №4
  c = 0;
  c = count.cnt5 + (((unsigned long int)MB_Hreg[52] << 16) + MB_Hreg[53]);	// коррекция значения счетчика №5
  MB_Ireg[19] = (c >> 16) & 0xFFFF;							// запись старшего числа счетчика №5
  MB_Ireg[20] = c & 0xFFFF;									// запись младшего числа счетчика №5
  c = 0;
  c = count.cnt6 + (((unsigned long int)MB_Hreg[54] << 16) + MB_Hreg[55]);	// коррекция значения счетчика №6
  MB_Ireg[21] = (c >> 16) & 0xFFFF;							// запись старшего числа счетчика №6
  MB_Ireg[22] = c & 0xFFFF;									// запись младшего числа счетчика №6
  c = 0;
  c = count.cnt7 + (((unsigned long int)MB_Hreg[56] << 16) + MB_Hreg[57]);	// коррекция значения счетчика №7
  MB_Ireg[23] = (c >> 16) & 0xFFFF;							// запись старшего числа счетчика №7
  MB_Ireg[24] = c & 0xFFFF;									// запись младшего числа счетчика №7
  c = 0;
  c = count.cnt8 + (((unsigned long int)MB_Hreg[58] << 16) + MB_Hreg[59]);	// коррекция значения счетчика №8
  MB_Ireg[25] = (c >> 16) & 0xFFFF;							// запись старшего числа счетчика №8
  MB_Ireg[26] = c & 0xFFFF;									// запись младшего числа счетчика №8
}

#endif
//************************************************** END ***********************************************************************************